package gitlab

import (
	_jsii_ "github.com/aws/jsii-runtime-go/runtime"
	_init_ "github.com/projen/projen-go/projen/jsii"

	"github.com/aws/constructs-go/constructs/v10"
	"github.com/projen/projen-go/projen"
	"github.com/projen/projen-go/projen/gitlab/internal"
)

// CI for GitLab.
//
// A CI is a configurable automated process made up of one or more stages/jobs.
// See: https://docs.gitlab.com/ee/ci/yaml/
//
// Experimental.
type CiConfiguration interface {
	projen.Component
	// Defines default scripts that should run *after* all jobs.
	//
	// Can be overriden by the job level `afterScript`.
	// Experimental.
	DefaultAfterScript() *[]*string
	// Default list of files and directories that should be attached to the job if it succeeds.
	//
	// Artifacts are sent to Gitlab where they can be downloaded.
	// Experimental.
	DefaultArtifacts() *Artifacts
	// Defines default scripts that should run *before* all jobs.
	//
	// Can be overriden by the job level `afterScript`.
	// Experimental.
	DefaultBeforeScript() *[]*string
	// Experimental.
	DefaultCache() *[]*Cache
	// Default ID tokens (JSON Web Tokens) that are used for CI/CD authentication to use globally for all jobs.
	// Experimental.
	DefaultIdTokens() *map[string]IDToken
	// Specifies the default docker image to use globally for all jobs.
	// Experimental.
	DefaultImage() *Image
	// The default behavior for whether a job should be canceled when a newer pipeline starts before the job completes (Default: false).
	// Experimental.
	DefaultInterruptible() *bool
	// How many times a job is retried if it fails.
	//
	// If not defined, defaults to 0 and jobs do not retry.
	// Experimental.
	DefaultRetry() *Retry
	// Used to select a specific runner from the list of all runners that are available for the project.
	// Experimental.
	DefaultTags() *[]*string
	// A default timeout job written in natural language (Ex.
	//
	// one hour, 3600 seconds, 60 minutes).
	// Experimental.
	DefaultTimeout() *string
	// The workflow YAML file.
	// Experimental.
	File() projen.YamlFile
	// The jobs in the CI configuration.
	// Experimental.
	Jobs() *map[string]*Job
	// The name of the configuration.
	// Experimental.
	Name() *string
	// The tree node.
	// Experimental.
	Node() constructs.Node
	// A special job used to upload static sites to Gitlab pages.
	//
	// Requires a `public/` directory
	// with `artifacts.path` pointing to it.
	// Experimental.
	Pages() *Job
	// Path to CI file generated by the configuration.
	// Experimental.
	Path() *string
	// Experimental.
	Project() projen.Project
	// Groups jobs into stages.
	//
	// All jobs in one stage must complete before next stage is
	// executed. Defaults to ['build', 'test', 'deploy'].
	// Experimental.
	Stages() *[]*string
	// Global variables that are passed to jobs.
	//
	// If the job already has that variable defined, the job-level variable takes precedence.
	// Experimental.
	Variables() *map[string]interface{}
	// Used to control pipeline behavior.
	// Experimental.
	Workflow() *Workflow
	// Adds up to 4 default caches configuration to the CI configuration.
	// Experimental.
	AddDefaultCaches(caches *[]*Cache)
	// Specify a list of commands to execute on the runner before cloning the Git repository and any submodules https://docs.gitlab.com/ci/yaml/#hookspre_get_sources_script.
	// Experimental.
	AddDefaultHooks(hooks *DefaultHooks)
	// Add a globally defined variable to the CI configuration.
	// Experimental.
	AddGlobalVariables(variables *map[string]interface{})
	// Add additional yml/yaml files to the CI includes.
	// Experimental.
	AddIncludes(includes ...*Include)
	// Add jobs and their stages to the CI configuration.
	// Experimental.
	AddJobs(jobs *map[string]*Job)
	// Add additional services.
	// Experimental.
	AddServices(services ...*Service)
	// Add stages to the CI configuration if not already present.
	// Experimental.
	AddStages(stages ...*string)
	// Called after synthesis.
	//
	// Order is *not* guaranteed.
	// Experimental.
	PostSynthesize()
	// Called before synthesis.
	// Experimental.
	PreSynthesize()
	// Synthesizes files to the project output directory.
	// Experimental.
	Synthesize()
	// Returns a string representation of this construct.
	// Experimental.
	ToString() *string
}

// The jsii proxy struct for CiConfiguration
type jsiiProxy_CiConfiguration struct {
	internal.Type__projenComponent
}

func (j *jsiiProxy_CiConfiguration) DefaultAfterScript() *[]*string {
	var returns *[]*string
	_jsii_.Get(
		j,
		"defaultAfterScript",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) DefaultArtifacts() *Artifacts {
	var returns *Artifacts
	_jsii_.Get(
		j,
		"defaultArtifacts",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) DefaultBeforeScript() *[]*string {
	var returns *[]*string
	_jsii_.Get(
		j,
		"defaultBeforeScript",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) DefaultCache() *[]*Cache {
	var returns *[]*Cache
	_jsii_.Get(
		j,
		"defaultCache",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) DefaultIdTokens() *map[string]IDToken {
	var returns *map[string]IDToken
	_jsii_.Get(
		j,
		"defaultIdTokens",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) DefaultImage() *Image {
	var returns *Image
	_jsii_.Get(
		j,
		"defaultImage",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) DefaultInterruptible() *bool {
	var returns *bool
	_jsii_.Get(
		j,
		"defaultInterruptible",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) DefaultRetry() *Retry {
	var returns *Retry
	_jsii_.Get(
		j,
		"defaultRetry",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) DefaultTags() *[]*string {
	var returns *[]*string
	_jsii_.Get(
		j,
		"defaultTags",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) DefaultTimeout() *string {
	var returns *string
	_jsii_.Get(
		j,
		"defaultTimeout",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) File() projen.YamlFile {
	var returns projen.YamlFile
	_jsii_.Get(
		j,
		"file",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) Jobs() *map[string]*Job {
	var returns *map[string]*Job
	_jsii_.Get(
		j,
		"jobs",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) Pages() *Job {
	var returns *Job
	_jsii_.Get(
		j,
		"pages",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) Path() *string {
	var returns *string
	_jsii_.Get(
		j,
		"path",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) Project() projen.Project {
	var returns projen.Project
	_jsii_.Get(
		j,
		"project",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) Stages() *[]*string {
	var returns *[]*string
	_jsii_.Get(
		j,
		"stages",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) Variables() *map[string]interface{} {
	var returns *map[string]interface{}
	_jsii_.Get(
		j,
		"variables",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_CiConfiguration) Workflow() *Workflow {
	var returns *Workflow
	_jsii_.Get(
		j,
		"workflow",
		&returns,
	)
	return returns
}


// Experimental.
func NewCiConfiguration(project projen.Project, name *string, options *CiConfigurationOptions) CiConfiguration {
	_init_.Initialize()

	if err := validateNewCiConfigurationParameters(project, name, options); err != nil {
		panic(err)
	}
	j := jsiiProxy_CiConfiguration{}

	_jsii_.Create(
		"projen.gitlab.CiConfiguration",
		[]interface{}{project, name, options},
		&j,
	)

	return &j
}

// Experimental.
func NewCiConfiguration_Override(c CiConfiguration, project projen.Project, name *string, options *CiConfigurationOptions) {
	_init_.Initialize()

	_jsii_.Create(
		"projen.gitlab.CiConfiguration",
		[]interface{}{project, name, options},
		c,
	)
}

// Test whether the given construct is a component.
// Experimental.
func CiConfiguration_IsComponent(x interface{}) *bool {
	_init_.Initialize()

	if err := validateCiConfiguration_IsComponentParameters(x); err != nil {
		panic(err)
	}
	var returns *bool

	_jsii_.StaticInvoke(
		"projen.gitlab.CiConfiguration",
		"isComponent",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
// Experimental.
func CiConfiguration_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	if err := validateCiConfiguration_IsConstructParameters(x); err != nil {
		panic(err)
	}
	var returns *bool

	_jsii_.StaticInvoke(
		"projen.gitlab.CiConfiguration",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

func (c *jsiiProxy_CiConfiguration) AddDefaultCaches(caches *[]*Cache) {
	if err := c.validateAddDefaultCachesParameters(caches); err != nil {
		panic(err)
	}
	_jsii_.InvokeVoid(
		c,
		"addDefaultCaches",
		[]interface{}{caches},
	)
}

func (c *jsiiProxy_CiConfiguration) AddDefaultHooks(hooks *DefaultHooks) {
	if err := c.validateAddDefaultHooksParameters(hooks); err != nil {
		panic(err)
	}
	_jsii_.InvokeVoid(
		c,
		"addDefaultHooks",
		[]interface{}{hooks},
	)
}

func (c *jsiiProxy_CiConfiguration) AddGlobalVariables(variables *map[string]interface{}) {
	if err := c.validateAddGlobalVariablesParameters(variables); err != nil {
		panic(err)
	}
	_jsii_.InvokeVoid(
		c,
		"addGlobalVariables",
		[]interface{}{variables},
	)
}

func (c *jsiiProxy_CiConfiguration) AddIncludes(includes ...*Include) {
	if err := c.validateAddIncludesParameters(&includes); err != nil {
		panic(err)
	}
	args := []interface{}{}
	for _, a := range includes {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		c,
		"addIncludes",
		args,
	)
}

func (c *jsiiProxy_CiConfiguration) AddJobs(jobs *map[string]*Job) {
	if err := c.validateAddJobsParameters(jobs); err != nil {
		panic(err)
	}
	_jsii_.InvokeVoid(
		c,
		"addJobs",
		[]interface{}{jobs},
	)
}

func (c *jsiiProxy_CiConfiguration) AddServices(services ...*Service) {
	if err := c.validateAddServicesParameters(&services); err != nil {
		panic(err)
	}
	args := []interface{}{}
	for _, a := range services {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		c,
		"addServices",
		args,
	)
}

func (c *jsiiProxy_CiConfiguration) AddStages(stages ...*string) {
	args := []interface{}{}
	for _, a := range stages {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		c,
		"addStages",
		args,
	)
}

func (c *jsiiProxy_CiConfiguration) PostSynthesize() {
	_jsii_.InvokeVoid(
		c,
		"postSynthesize",
		nil, // no parameters
	)
}

func (c *jsiiProxy_CiConfiguration) PreSynthesize() {
	_jsii_.InvokeVoid(
		c,
		"preSynthesize",
		nil, // no parameters
	)
}

func (c *jsiiProxy_CiConfiguration) Synthesize() {
	_jsii_.InvokeVoid(
		c,
		"synthesize",
		nil, // no parameters
	)
}

func (c *jsiiProxy_CiConfiguration) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		c,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

